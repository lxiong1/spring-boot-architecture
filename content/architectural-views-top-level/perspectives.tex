\section{Perspectives}

\subsection{Usability}
The usability of Spring Boot is promoted by abstracting complex functions into annotations that are available to use by Java developer. Developers are champions in advocating for simple and reusable code, and this is where Spring Boot shines. From their perspective, it does not matter how Spring Boot internally works, but what it offers them to make their web application development efforts easier. Although this may sound great -- as with any new framework -- there is a learning curve to understand how to properly use and integrate it with an application. Spring in general however, is a extremely familiar software ecosystem to the Java development community. There is an abundant amount of Spring Boot resources such as videos, articles, blogs, forums, and other media platforms to learn from. This is in addition to the availability of Spring Boot maintainers that can answer questions and address concerns through GitHub and Stack Overflow. This is undoubtedly one of the reasons why Spring Boot is popular amongst Java developers and why they may choose to use it over other similar frameworks.\\

Java developers should be able to easily use Spring Boot framework once they understand the high level idea of how it works. That is to say, to understand on the high level what the annotations do and how they relate to one another when applying them to code.

\subsection{Evolution}
The evolution perspective has little to no impact on the deployment viewpoint, but has large implications on Spring Boot from a functional viewpoint. The direction from which the framework has to be adjusted is heavily in the hands of its' community of users, as the framework itself is open-source project. The features that are developed, enhancements that are made to give a better development experience, and fixes that patch bugs and vulnerabilities are all community-driven but ultimately addressed by the Spring Boot team. The Spring Boot team are the assessors of the trade-offs of every change requested from the community; they have to carefully consider every potential consequence of changes, the benefits, and the opportunities it opens up for the future.\\

For example, the decision to create the Spring Boot project was out of the common frustration to write boilerplate configuration as code, when it could just have been automated to avoid the frustration altogether. The implication of this however is that users are unaware of the Spring Boot magic behind why their web applications just works, so there is ignorance on behalf of the user. This ignorance can manifest itself in many ways, one of which the user does not understand why most dependencies are auto-configured and some are not. As users of Spring Boot, they would have to dig into the code and be hassled with the immense complexity to figure out why certain dependencies were not auto-configured or ask the larger Spring Boot community. The huge upside simply, is that it just works for most situations regardless of whether the user has thorough understanding of the internal workings of Spring Boot or not. The bigger idea here, is that when the issues arise with using the Spring Boot framework, the user typically will be lost and look to the community at large. That is the trade-off with abstraction.\\

The Spring Boot architecture is reliant on external dependencies. It therefore is nothing without the existence of those external dependencies because it's primary job is to auto-configure them. To put it another way, the architectural evolution of Spring Boot is directly tied to libraries outside of its' control. The way the code is written to auto-configure those libraries is up to the way they were developed.

\subsection{Development Resource}
Development resource is extremely important to the functional viewpoint because of the complexity of abstraction of Spring Boot's code. For a person to be able to meaningfully contribute to the core of the codebase, a developer in the Spring Boot team has to understand how Spring Boot internally works. It requires that the person understands how to utilize design patterns in specific situations to implement new code, let alone how to read code to understand the design patterns going on in the codebase. This also touches on the understanding of the information viewpoint because of the runtime data flow within the Spring Boot framework to auto-configure dependencies. Both of these viewpoints affects how a developer would refactor, extend, and design the codebase for sustainability and maintainability. For the deployment viewpoint, a developer must have special knowledge on system engineering, creating automated pipelines to achieve the goal of deploying the Spring Boot framework confidently, effectively, and efficiently. This is all the more important since it is a framework used by so many developers around the world, so there is quite an impact when done incorrectly. All of this requires a developer have quite expansive knowledge no matter where they may specialize within the Spring Boot team. To bring a new developer up to speed may require a lot of time, let alone the rigorous coding standards that the team imposes on the development of the framework.
